# =============================================================================
# WARNING: This is generated code - DO NOT EDIT!!!
# =============================================================================

{% if response_models %}
# Import response models
from .models import *
{% endif %}

from typing import Optional, List, Dict, Any, Union, TypeAlias, TypedDict, Literal, cast, Iterator, AsyncIterator, get_type_hints, get_origin, get_args
import requests
import json
import inspect
from dataclasses import dataclass
from functools import lru_cache, wraps
import time

{% if async_support %}
import httpx
import asyncio
from typing import AsyncIterator
{% endif %}

# Type aliases for better clarity
ResponseDict: TypeAlias = Dict[str, Any]
StreamingResponse: TypeAlias = Union[requests.Response, "httpx.Response"]

def validate_params(func):
    """Decorator to validate parameters against type hints at runtime."""
    @wraps(func)
    def wrapper(self, *args, **kwargs):
        if not getattr(self, '_enable_type_checking', True):
            return func(self, *args, **kwargs)
            
        sig = inspect.signature(func)
        params = sig.parameters
        
        # Skip self parameter
        param_items = list(params.items())[1:]
        
        # Get type hints
        hints = get_type_hints(func)
        
        # Check positional args
        for i, (name, param) in enumerate(param_items):
            if i < len(args):
                arg_value = args[i]
                param_type = hints.get(name)
                
                if param_type and not isinstance(arg_value, type(None)) and arg_value is not None:
                    # Handle Union/Optional types
                    if get_origin(param_type) in (Union, Optional):
                        type_args = get_args(param_type)
                        if not any(isinstance(arg_value, arg) for arg in type_args if arg is not type(None)):
                            raise TypeError(f"Parameter '{name}' expected one of {type_args}, got {type(arg_value)}")
                    # Handle simple types
                    elif not isinstance(arg_value, param_type):
                        raise TypeError(f"Parameter '{name}' expected {param_type}, got {type(arg_value)}")
        
        # Check keyword args
        for name, value in kwargs.items():
            if name in hints and value is not None:
                param_type = hints[name]
                
                # Handle Union/Optional types
                if get_origin(param_type) in (Union, Optional):
                    type_args = get_args(param_type)
                    if not any(isinstance(value, arg) for arg in type_args if arg is not type(None)):
                        raise TypeError(f"Parameter '{name}' expected one of {type_args}, got {type(value)}")
                # Handle simple types
                elif not isinstance(value, param_type):
                    raise TypeError(f"Parameter '{name}' expected {param_type}, got {type(value)}")
        
        return func(self, *args, **kwargs)
    
    return wrapper
    
{% if async_support %}
def validate_params_async(func):
    """Decorator to validate parameters against type hints at runtime for async functions."""
    @wraps(func)
    async def wrapper(self, *args, **kwargs):
        if not getattr(self, '_enable_type_checking', True):
            return await func(self, *args, **kwargs)
            
        sig = inspect.signature(func)
        params = sig.parameters
        
        # Skip self parameter
        param_items = list(params.items())[1:]
        
        # Get type hints
        hints = get_type_hints(func)
        
        # Check positional args
        for i, (name, param) in enumerate(param_items):
            if i < len(args):
                arg_value = args[i]
                param_type = hints.get(name)
                
                if param_type and not isinstance(arg_value, type(None)) and arg_value is not None:
                    # Handle Union/Optional types
                    if get_origin(param_type) in (Union, Optional):
                        type_args = get_args(param_type)
                        if not any(isinstance(arg_value, arg) for arg in type_args if arg is not type(None)):
                            raise TypeError(f"Parameter '{name}' expected one of {type_args}, got {type(arg_value)}")
                    # Handle simple types
                    elif not isinstance(arg_value, param_type):
                        raise TypeError(f"Parameter '{name}' expected {param_type}, got {type(arg_value)}")
        
        # Check keyword args
        for name, value in kwargs.items():
            if name in hints and value is not None:
                param_type = hints[name]
                
                # Handle Union/Optional types
                if get_origin(param_type) in (Union, Optional):
                    type_args = get_args(param_type)
                    if not any(isinstance(value, arg) for arg in type_args if arg is not type(None)):
                        raise TypeError(f"Parameter '{name}' expected one of {type_args}, got {type(value)}")
                # Handle simple types
                elif not isinstance(value, param_type):
                    raise TypeError(f"Parameter '{name}' expected {param_type}, got {type(value)}")
        
        return await func(self, *args, **kwargs)
    
    return wrapper
{% endif %}

class ApiError(Exception):
    """Base exception for API errors"""
    def __init__(self, message: str, status_code: Optional[int] = None, error_code: Optional[str] = None):
        self.status_code = status_code
        self.error_code = error_code
        super().__init__(message)


class AuthenticationError(ApiError):
    """Raised when authentication fails (401)"""
    pass


class PermissionError(ApiError):
    """Raised when permission is denied (403)"""
    pass


class ResourceNotFoundError(ApiError):
    """Raised when a resource is not found (404)"""
    pass


class ValidationError(ApiError):
    """Raised when request validation fails (422)"""
    pass


class RateLimitError(ApiError):
    """Raised when rate limit is exceeded (429)"""
    pass


class ServerError(ApiError):
    """Raised for server errors (5xx)"""
    pass

@dataclass(frozen=True)
class ClientConfig:
    """Configuration options for API client behavior."""
    
    # Timeout in seconds for API requests
    timeout: float = 30.0
    
    # Whether to retry failed requests
    retry_enabled: bool = True
    
    # Maximum number of retries
    max_retries: int = 3
    
    # Backoff factor for retries (in seconds)
    retry_backoff_factor: float = 0.5
    
    # Status codes to retry on
    retry_status_codes: List[int] = (408, 429, 500, 502, 503, 504)
    
    # Whether to validate parameter types at runtime
    enable_type_checking: bool = True
    
    # Whether to compress request bodies
    compress: bool = True
    
    # User agent to send with requests
    user_agent: str = "{{ title }}SDK/1.0.0"
    
    {% if async_support %}
    # Timeout for async requests
    async_timeout: float = 30.0
    
    # Connection pool limits
    max_connections: int = 100
    max_keepalive_connections: int = 20
    keepalive_expiry: float = 120.0
    {% endif %}

class {{ title }}Client:
    """{{ description }}
    """

    def __init__(
        self, 
        {% if security_schemes %}
        {% for scheme_name, scheme in security_schemes.items() %}
        {% if scheme.type == 'apiKey' %}
        {{ to_snake_case(scheme_name) }}: str,
        {% elif (scheme.type == 'http' and scheme.scheme == 'bearer') or scheme.type == 'bearer' %}
        jwt_token: str,
        {% elif scheme.type == 'oauth2' %}
        oauth_token: str,
        {% endif %}
        {% endfor %}
        {% else %}
        jwt_token: str,
        {% endif %}
        base_url: str = "{{ base_url }}",
        config: Optional[ClientConfig] = None
    ):
        """
        Initializes the {{ title }}Client.

        Args:
            {% if security_schemes %}
            {% for scheme_name, scheme in security_schemes.items() %}
            {% if scheme.type == 'apiKey' %}
            {{ to_snake_case(scheme_name) }}: {{ scheme.description or "API key for authorization" }}
            {% elif (scheme.type == 'http' and scheme.scheme == 'bearer') or scheme.type == 'bearer' %}
            jwt_token: {{ scheme.description or "JWT token for authorization" }}
            {% elif scheme.type == 'oauth2' %}
            oauth_token: {{ scheme.description or "OAuth token for authorization" }}
            {% endif %}
            {% endfor %}
            {% else %}
            jwt_token: JWT token for authorization
            {% endif %}
            base_url: The base URL for the API.
            config: Optional client configuration
        """
        self.base_url = base_url
        self.config = config or ClientConfig()
        
        # Configure requests session with config options
        self.session = requests.Session()
        self.session.headers.update({'User-Agent': self.config.user_agent})
        
        # Store type checking preference
        self._enable_type_checking = self.config.enable_type_checking
        
        # Set up auth headers based on security schemes
        {% if security_schemes %}
        {% for scheme_name, scheme in security_schemes.items() %}
        {% if scheme.type == 'apiKey' %}
        {% if scheme.in == 'header' %}
        self.session.headers.update({'{{ scheme.name }}': {{ to_snake_case(scheme_name) }}})
        {% elif scheme.in == 'query' %}
        # Query parameter auth will be added to each request
        self._api_key_param = {'{{ scheme.name }}': {{ to_snake_case(scheme_name) }}}
        {% endif %}
        {% elif (scheme.type == 'http' and scheme.scheme == 'bearer') or scheme.type == 'bearer' %}
        self.session.headers.update({'Authorization': f'Bearer {jwt_token}'})
        {% elif scheme.type == 'oauth2' %}
        self.session.headers.update({'Authorization': f'Bearer {oauth_token}'})
        {% endif %}
        {% endfor %}
        {% else %}
        self.session.headers.update({
            'Authorization': f'Bearer {jwt_token}'
        })
        {% endif %}
        
        # For supporting query parameter auth
        self._additional_params = {}
        {% if security_schemes %}
        {% for scheme_name, scheme in security_schemes.items() %}
        {% if scheme.type == 'apiKey' and scheme.in == 'query' %}
        self._additional_params.update(self._api_key_param)
        {% endif %}
        {% endfor %}
        {% endif %}

        {% if async_support %}
        # Configure async client with config options
        self.async_client = httpx.AsyncClient(
            base_url=base_url,
            headers={
                {% if security_schemes %}
                {% for scheme_name, scheme in security_schemes.items() %}
                {% if scheme.type == 'apiKey' and scheme.in == 'header' %}
                '{{ scheme.name }}': {{ to_snake_case(scheme_name) }},
                {% elif (scheme.type == 'http' and scheme.scheme == 'bearer') or scheme.type == 'bearer' %}
                'Authorization': f'Bearer {jwt_token}',
                {% elif scheme.type == 'oauth2' %}
                'Authorization': f'Bearer {oauth_token}',
                {% endif %}
                {% endfor %}
                {% else %}
                'Authorization': f'Bearer {jwt_token}',
                {% endif %}
                'User-Agent': self.config.user_agent
            },
            timeout=httpx.Timeout(self.config.async_timeout),
            limits=httpx.Limits(
                max_connections=self.config.max_connections,
                max_keepalive_connections=self.config.max_keepalive_connections,
                keepalive_expiry=self.config.keepalive_expiry
            )
        )
        {% endif %}

    def _make_request(self, method: str, path: str, params: Optional[dict] = None, data: Optional[dict] = None,
                      headers: Optional[dict] = None, stream: bool = False) -> Union[requests.Response, dict, str, bytes]:
        """
        Makes a request to the API.  Handles JSON serialization and error responses.

        Args:
            method: The HTTP method (GET, POST, PUT, DELETE, PATCH, HEAD).
            path: The API endpoint path (e.g., "/api/v1/notifications").
            params: Query parameters (optional).
            data: Request body data (will be converted to JSON) (optional).
            headers: Custom headers (optional).
            stream: Whether to stream the response (for NDJSON responses).

        Returns:
            The response.  If the response is JSON, it's automatically decoded.
            If the response is NDJSON and stream=True, it returns the raw response object for streaming.
            Otherwise it returns the raw string.

        Raises:
            AuthenticationError: When authentication fails (401)
            PermissionError: When permission is denied (403)
            ResourceNotFoundError: When a resource is not found (404)
            ValidationError: When request validation fails (422) 
            RateLimitError: When rate limit is exceeded (429)
            ServerError: For server-side errors (5xx)
            ApiError: For other API errors
            ValueError: For other client-side errors, like JSON encoding issues.
        """

        url = f"{self.base_url}{path}"

        # Start with a copy of the session headers
        request_headers = self.session.headers.copy()

        # Update with any custom headers, but don't overwrite existing ones
        if headers:
            for key, value in headers.items():
                if key not in request_headers:  # Prioritize session headers
                    request_headers[key] = value

        # Prepare query parameters, including API key params if needed
        request_params = {}
        if self._additional_params:
            request_params.update(self._additional_params)
        if params:
            request_params.update(params)

        if data is not None:
            request_headers['Content-Type'] = 'application/json'  # Set Content-Type for JSON data
            data = json.dumps(data)

        # Set up retry logic
        retry_count = 0
        max_retries = self.config.max_retries if self.config.retry_enabled else 0
        backoff_factor = self.config.retry_backoff_factor
        retry_codes = set(self.config.retry_status_codes)
        
        while True:
            try:
                response = self.session.request(
                    method, 
                    url, 
                    params=request_params, 
                    data=data, 
                    headers=request_headers, 
                    stream=stream,
                    timeout=self.config.timeout
                )
                
                # If response is successful or retries are disabled, process response
                if response.ok or not self.config.retry_enabled:
                    break
                    
                # Check if status code is in retry codes
                if response.status_code in retry_codes and retry_count < max_retries:
                    retry_count += 1
                    # Calculate backoff time: {backoff_factor} * (2 ^ ({retry_count} - 1))
                    backoff_time = backoff_factor * (2 ** (retry_count - 1))
                    time.sleep(backoff_time)
                    continue
                    
                # If we get here, either retries are exhausted or status not retryable
                break
                    
            except requests.RequestException as e:
                # Retry on connection errors if retries not exhausted
                if retry_count < max_retries and self.config.retry_enabled:
                    retry_count += 1
                    backoff_time = backoff_factor * (2 ** (retry_count - 1))
                    time.sleep(backoff_time)
                    continue
                # Raise if retries exhausted
                raise ApiError(f"Request failed after {retry_count} retries: {str(e)}")
                
        # Handle errors with appropriate exception classes
        if not response.ok:
            status_code = response.status_code
            try:
                error_json = response.json()
                detail = error_json.get("detail", "Unknown error")
                error_code = error_json.get("error_code", "unknown_error_code")
                
                # Map status codes to appropriate exceptions
                if status_code == 401:
                    raise AuthenticationError(f"Authentication failed: {detail}", status_code, error_code)
                elif status_code == 403:
                    raise PermissionError(f"Permission denied: {detail}", status_code, error_code)
                elif status_code == 404:
                    raise ResourceNotFoundError(f"Resource not found: {detail}", status_code, error_code)
                elif status_code == 422:
                    raise ValidationError(f"Validation error: {detail}", status_code, error_code)
                elif status_code == 429:
                    raise RateLimitError(f"Rate limit exceeded: {detail}", status_code, error_code)
                elif 500 <= status_code < 600:
                    raise ServerError(f"Server error: {detail}", status_code, error_code)
                else:
                    raise ApiError(f"API error: {detail}", status_code, error_code)
            except json.JSONDecodeError:
                # Fallback for non-JSON error responses
                error_text = response.text[:100] + ("..." if len(response.text) > 100 else "")
                if status_code == 401:
                    raise AuthenticationError(f"Authentication failed: {error_text}", status_code)
                elif status_code == 403:
                    raise PermissionError(f"Permission denied: {error_text}", status_code)
                elif status_code == 404:
                    raise ResourceNotFoundError(f"Resource not found: {error_text}", status_code)
                elif status_code == 429:
                    raise RateLimitError(f"Rate limit exceeded: {error_text}", status_code)
                elif 500 <= status_code < 600:
                    raise ServerError(f"Server error: {error_text}", status_code)
                else:
                    raise ApiError(f"API error: {error_text}", status_code)

        if stream:
            return response
        elif response.headers.get('Content-Type', '').startswith('application/json'):
            return response.json()
        elif response.headers.get('Content-Type', '').startswith('application/x-ndjson'):
            return response.text
        else:
            return response.content

    {% if async_support %}
    async def _make_request_async(self, method: str, path: str, params: Optional[dict] = None, 
                           data: Optional[dict] = None, headers: Optional[dict] = None, 
                           stream: bool = False) -> Union[Dict[str, Any], str, bytes, httpx.Response]:
        """
        Makes an async request to the API. Handles JSON serialization and error responses.
        
        Args:
            (Same as _make_request)
            
        Returns:
            The response data, similar to _make_request but in async context.
            
        Raises:
            httpx.HTTPStatusError: If the API returns an error status code
            ValueError: For other client-side errors
        """
        url = path  # base_url is set in async_client
        
        request_headers = {}
        if headers:
            request_headers.update(headers)
            
        # Prepare query parameters, including API key params if needed
        request_params = {}
        if self._additional_params:
            request_params.update(self._additional_params)
        if params:
            request_params.update(params)
            
        json_data = None
        if data is not None:
            request_headers['Content-Type'] = 'application/json'
            json_data = data  # httpx handles JSON serialization
            
        # Set up retry logic
        retry_count = 0
        max_retries = self.config.max_retries if self.config.retry_enabled else 0
        backoff_factor = self.config.retry_backoff_factor
        retry_codes = set(self.config.retry_status_codes)
        
        while True:
            try:
                response = await self.async_client.request(
                    method, 
                    url, 
                    params=request_params, 
                    json=json_data,
                    headers=request_headers
                )
                
                # If response is successful or retries are disabled, process response
                if response.is_success or not self.config.retry_enabled:
                    break
                    
                # Check if status code is in retry codes
                if response.status_code in retry_codes and retry_count < max_retries:
                    retry_count += 1
                    # Calculate backoff time
                    backoff_time = backoff_factor * (2 ** (retry_count - 1))
                    await asyncio.sleep(backoff_time)
                    continue
                    
                # If we get here, either retries are exhausted or status not retryable
                break
                    
            except httpx.RequestError as e:
                # Retry on connection errors if retries not exhausted
                if retry_count < max_retries and self.config.retry_enabled:
                    retry_count += 1
                    backoff_time = backoff_factor * (2 ** (retry_count - 1))
                    await asyncio.sleep(backoff_time)
                    continue
                # Raise if retries exhausted
                raise ApiError(f"Async request failed after {retry_count} retries: {str(e)}")
                
        # Handle errors with appropriate exception classes
        if not response.is_success:
            status_code = response.status_code
            try:
                error_json = response.json()
                detail = error_json.get("detail", "Unknown error")
                error_code = error_json.get("error_code", "unknown_error_code") 
                
                # Map status codes to appropriate exceptions
                if status_code == 401:
                    raise AuthenticationError(f"Authentication failed: {detail}", status_code, error_code)
                elif status_code == 403:
                    raise PermissionError(f"Permission denied: {detail}", status_code, error_code)
                elif status_code == 404:
                    raise ResourceNotFoundError(f"Resource not found: {detail}", status_code, error_code)
                elif status_code == 422:
                    raise ValidationError(f"Validation error: {detail}", status_code, error_code)
                elif status_code == 429:
                    raise RateLimitError(f"Rate limit exceeded: {detail}", status_code, error_code)
                elif 500 <= status_code < 600:
                    raise ServerError(f"Server error: {detail}", status_code, error_code)
                else:
                    raise ApiError(f"API error: {detail}", status_code, error_code)
            except (ValueError, json.JSONDecodeError):
                # Fallback for non-JSON error responses
                error_text = response.text[:100] + ("..." if len(response.text) > 100 else "")
                if status_code == 401:
                    raise AuthenticationError(f"Authentication failed: {error_text}", status_code)
                elif status_code == 403:
                    raise PermissionError(f"Permission denied: {error_text}", status_code)
                elif status_code == 404:
                    raise ResourceNotFoundError(f"Resource not found: {error_text}", status_code)
                elif status_code == 429:
                    raise RateLimitError(f"Rate limit exceeded: {error_text}", status_code)
                elif 500 <= status_code < 600:
                    raise ServerError(f"Server error: {error_text}", status_code)
                else:
                    raise ApiError(f"API error: {error_text}", status_code)
            
        if stream:
            return response
        elif response.headers.get('Content-Type', '').startswith('application/json'):
            return response.json()
        elif response.headers.get('Content-Type', '').startswith('application/x-ndjson'):
            return response.text
        else:
            return response.content
    {% endif %}

    def _iterate_ndjson(self, response: StreamingResponse) -> Iterator[Dict[str, Any]]:
        """
        Iterate over a streaming NDJSON response.
        
        Args:
            response: A streaming response containing NDJSON data
            
        Yields:
            Each JSON object in the stream
        """
        for line in response.iter_lines():
            if line:
                try:
                    yield json.loads(line)
                except json.JSONDecodeError:
                    # Skip malformed lines
                    continue

    {% if async_support %}
    async def _iterate_ndjson_async(self, response: httpx.Response) -> AsyncIterator[Dict[str, Any]]:
        """
        Asynchronously iterate over a streaming NDJSON response.
        
        Args:
            response: A streaming response containing NDJSON data
            
        Yields:
            Each JSON object in the stream
        """
        async for line in response.aiter_lines():
            if line:
                try:
                    yield json.loads(line)
                except json.JSONDecodeError:
                    # Skip malformed lines
                    continue
    {% endif %}

{% for path, methods in paths.items() %}
{% for method, method_spec in methods.items() %}
{% if method_spec is mapping and method_spec.get('operationId') %}
    @validate_params
    def {{ to_snake_case(method_spec.operationId.split('_api_')[0]) }}(self, *, 
        {% for param in method_spec.get('parameters', []) %}
        {% if param.in == "path" %}{{ param.name }}: {{ get_type_from_schema(param.schema) }}, {% endif %}
        {% endfor %}
        {% for param in method_spec.get('parameters', []) %}
        {% if param.in == "query" %}
        {% set param_type = get_type_from_schema(param.schema) %}
        {% if param.get('required', False) %}
        {{ param.name }}: {{ param_type }}, 
        {% else %}
        {{ param.name }}: Optional[{{ param_type }}] = {{ get_default_value(param.schema) or 'None' }}, 
        {% endif %}
        {% endif %}
        {% endfor %}
        {% if is_openapi3 %}
        {% for param in get_request_body_params(method_spec.get('requestBody')) %}
        {{ param.name }}: {% if param.get('required') %}{{ param.type }}{% else %}Optional[{{ param.type }}] = {{ param.default or 'None' }}{% endif %}, 
        {% endfor %}
        {% else %}
        {% for param in method_spec.get('parameters', []) %}
        {% if param.in == "body" %}
        {% for body_param in get_request_body_params(param.schema) %}
        {{ body_param.name }}: {% if body_param.get('required') %}{{ body_param.type }}{% else %}Optional[{{ body_param.type }}] = {{ body_param.default or 'None' }}{% endif %}, 
        {% endfor %}
        {% endif %}
        {% endfor %}
        {% endif %}
        request_kwargs: Optional[Dict[str, Any]] = None
    ) -> {% if response_models and "200" in method_spec.responses and ((is_openapi3 and method_spec.responses["200"].get("content", {}).get("application/json", {}).get("schema", {}).get("$ref")) or (not is_openapi3 and method_spec.responses["200"].get("schema", {}).get("$ref"))) %}{% if is_openapi3 %}{{ method_spec.responses["200"].content["application/json"].schema["$ref"].split('/')[-1] }}{% else %}{{ method_spec.responses["200"].schema["$ref"].split('/')[-1] }}{% endif %}{% else %}{{ get_response_type(method_spec.responses) }}{% endif %}:
        """{{ method_spec.get('summary', '') }}

        {{ method_spec.get('description', '') }}
{% if method_spec.get('parameters') or (is_openapi3 and method_spec.get('requestBody')) %}
        Args:
{% for param in method_spec.get('parameters', []) %}
            {{ param.name }}: {{ param.get('description', '') }}
{% endfor %}
{% if is_openapi3 %}
{% for param in get_request_body_params(method_spec.get('requestBody')) %}
            {{ param.name }}: {{ param.get('description', '') }}
{% endfor %}
{% endif %}
            request_kwargs: Optional[Dict[str, Any]]. Additional keyword arguments to pass to requests.request.
{% endif %}
{% if "200" in method_spec.responses %}
        Returns:
            {{ method_spec.responses["200"].get("description", "") }}
{% endif %}
        """
        params = {}
        {% for param in method_spec.get('parameters', []) %}
        {% if param.in == "query" %}
        {% if param.get('required', False) %}
        params["{{ param.name }}"] = {{ param.name }}
        {% else %}
        if {{ param.name }} is not None:
            params["{{ param.name }}"] = {{ param.name }}
        {% endif %}
        {% endif %}
        {% endfor %}

        data = {}
        {% if is_openapi3 %}
        {% for param in get_request_body_params(method_spec.get('requestBody')) %}
        if {{ param.name }} is not None:  # Only include if not None
            data["{{ param.name }}"] = {{ param.name }}
        {% endfor %}
        {% else %}
        {% for param in method_spec.get('parameters', []) %}
        {% if param.in == "body" %}
        {% for body_param in get_request_body_params(param.schema) %}
        if {{ body_param.name }} is not None:  # Only include if not None
            data["{{ body_param.name }}"] = {{ body_param.name }}
        {% endfor %}
        {% endif %}
        {% endfor %}
        {% endif %}

        {% set is_streaming = False %}
        {% if "200" in method_spec.responses and is_openapi3 and method_spec.responses["200"].get("content") and "application/x-ndjson" in method_spec.responses["200"].content %}
            {% set is_streaming = True %}
        {% endif %}

        # Use request_kwargs for any additional options
        if request_kwargs is None:
            request_kwargs = {}
        raw_response = self._make_request("{{ method.upper() }}", "{{ path }}", params=params, data=data if data else None, stream={{ is_streaming }}, **request_kwargs)
        
        {% if response_models and "200" in method_spec.responses and ((is_openapi3 and method_spec.responses["200"].get("content", {}).get("application/json", {}).get("schema", {}).get("$ref")) or (not is_openapi3 and method_spec.responses["200"].get("schema", {}).get("$ref"))) %}
        # Convert raw response to model object
        {% if is_openapi3 %}
        return {{ method_spec.responses["200"].content["application/json"].schema["$ref"].split('/')[-1] }}(**raw_response)
        {% else %}
        return {{ method_spec.responses["200"].schema["$ref"].split('/')[-1] }}(**raw_response)
        {% endif %}
        {% else %}
        return raw_response
        {% endif %}

    {% if is_streaming %}
    @validate_params
    def {{ to_snake_case(method_spec.operationId.split('_api_')[0]) }}_iter(self, *, 
        {% for param in method_spec.get('parameters', []) %}
        {% if param.in == "path" %}{{ param.name }}: {{ get_type_from_schema(param.schema) }}, {% endif %}
        {% endfor %}
        {% for param in method_spec.get('parameters', []) %}
        {% if param.in == "query" %}
        {% set param_type = get_type_from_schema(param.schema) %}
        {% if param.get('required', False) %}
        {{ param.name }}: {{ param_type }}, 
        {% else %}
        {{ param.name }}: Optional[{{ param_type }}] = {{ get_default_value(param.schema) or 'None' }}, 
        {% endif %}
        {% endif %}
        {% endfor %}
        {% if is_openapi3 %}
        {% for param in get_request_body_params(method_spec.get('requestBody')) %}
        {{ param.name }}: {% if param.get('required') %}{{ param.type }}{% else %}Optional[{{ param.type }}] = {{ param.default or 'None' }}{% endif %}, 
        {% endfor %}
        {% else %}
        {% for param in method_spec.get('parameters', []) %}
        {% if param.in == "body" %}
        {% for body_param in get_request_body_params(param.schema) %}
        {{ body_param.name }}: {% if body_param.get('required') %}{{ body_param.type }}{% else %}Optional[{{ body_param.type }}] = {{ body_param.default or 'None' }}{% endif %}, 
        {% endfor %}
        {% endif %}
        {% endfor %}
        {% endif %}
        request_kwargs: Optional[Dict[str, Any]] = None
    ) -> Iterator[Dict[str, Any]]:
        """{{ method_spec.get('summary', '') }} (streaming iterator version)

        {{ method_spec.get('description', '') }}
        
        Provides an iterator that yields each NDJSON item as it's received.
        
        Args:
            (Same as {{ to_snake_case(method_spec.operationId.split('_api_')[0]) }})
            
        Yields:
            Each JSON object from the stream
        """
        params = {}
        {% for param in method_spec.get('parameters', []) %}
        {% if param.in == "query" %}
        {% if param.get('required', False) %}
        params["{{ param.name }}"] = {{ param.name }}
        {% else %}
        if {{ param.name }} is not None:
            params["{{ param.name }}"] = {{ param.name }}
        {% endif %}
        {% endif %}
        {% endfor %}

        data = {}
        {% if is_openapi3 %}
        {% for param in get_request_body_params(method_spec.get('requestBody')) %}
        if {{ param.name }} is not None:  # Only include if not None
            data["{{ param.name }}"] = {{ param.name }}
        {% endfor %}
        {% else %}
        {% for param in method_spec.get('parameters', []) %}
        {% if param.in == "body" %}
        {% for body_param in get_request_body_params(param.schema) %}
        if {{ body_param.name }} is not None:  # Only include if not None
            data["{{ body_param.name }}"] = {{ body_param.name }}
        {% endfor %}
        {% endif %}
        {% endfor %}
        {% endif %}

        # Use request_kwargs for any additional options
        if request_kwargs is None:
            request_kwargs = {}
        response = self._make_request("{{ method.upper() }}", "{{ path }}", params=params, data=data if data else None, stream=True, **request_kwargs)
        
        return self._iterate_ndjson(response)
    {% endif %}

    {% if async_support and is_streaming %}
    @validate_params_async
    async def {{ to_snake_case(method_spec.operationId.split('_api_')[0]) }}_aiter(self, *, 
        {% for param in method_spec.get('parameters', []) %}
        {% if param.in == "path" %}{{ param.name }}: {{ get_type_from_schema(param.schema) }}, {% endif %}
        {% endfor %}
        {% for param in method_spec.get('parameters', []) %}
        {% if param.in == "query" %}
        {% set param_type = get_type_from_schema(param.schema) %}
        {% if param.get('required', False) %}
        {{ param.name }}: {{ param_type }}, 
        {% else %}
        {{ param.name }}: Optional[{{ param_type }}] = {{ get_default_value(param.schema) or 'None' }}, 
        {% endif %}
        {% endif %}
        {% endfor %}
        {% if is_openapi3 %}
        {% for param in get_request_body_params(method_spec.get('requestBody')) %}
        {{ param.name }}: {% if param.get('required') %}{{ param.type }}{% else %}Optional[{{ param.type }}] = {{ param.default or 'None' }}{% endif %}, 
        {% endfor %}
        {% else %}
        {% for param in method_spec.get('parameters', []) %}
        {% if param.in == "body" %}
        {% for body_param in get_request_body_params(param.schema) %}
        {{ body_param.name }}: {% if body_param.get('required') %}{{ body_param.type }}{% else %}Optional[{{ body_param.type }}] = {{ body_param.default or 'None' }}{% endif %}, 
        {% endfor %}
        {% endif %}
        {% endfor %}
        {% endif %}
        request_kwargs: Optional[Dict[str, Any]] = None
    ) -> AsyncIterator[Dict[str, Any]]:
        """{{ method_spec.get('summary', '') }} (async streaming iterator version)

        {{ method_spec.get('description', '') }}
        
        Provides an async iterator that yields each NDJSON item as it's received.
        
        Args:
            (Same as {{ to_snake_case(method_spec.operationId.split('_api_')[0]) }})
            
        Yields:
            Each JSON object from the stream
        """
        params = {}
        {% for param in method_spec.get('parameters', []) %}
        {% if param.in == "query" %}
        {% if param.get('required', False) %}
        params["{{ param.name }}"] = {{ param.name }}
        {% else %}
        if {{ param.name }} is not None:
            params["{{ param.name }}"] = {{ param.name }}
        {% endif %}
        {% endif %}
        {% endfor %}

        data = {}
        {% if is_openapi3 %}
        {% for param in get_request_body_params(method_spec.get('requestBody')) %}
        if {{ param.name }} is not None:  # Only include if not None
            data["{{ param.name }}"] = {{ param.name }}
        {% endfor %}
        {% else %}
        {% for param in method_spec.get('parameters', []) %}
        {% if param.in == "body" %}
        {% for body_param in get_request_body_params(param.schema) %}
        if {{ body_param.name }} is not None:  # Only include if not None
            data["{{ body_param.name }}"] = {{ body_param.name }}
        {% endfor %}
        {% endif %}
        {% endfor %}
        {% endif %}

        # Use request_kwargs for any additional options
        if request_kwargs is None:
            request_kwargs = {}
        response = await self._make_request_async("{{ method.upper() }}", "{{ path }}", params=params, data=data if data else None, stream=True, **request_kwargs)
        
        return self._iterate_ndjson_async(response)
    {% endif %}
{% endif %}
{% endfor %}
{% endfor %}

    async def close(self):
        """Close any open connections."""
        {% if async_support %}
        await self.async_client.aclose()
        {% endif %}
        self.session.close()
        
    def __enter__(self):
        """Support for using client as a context manager."""
        return self
        
    def __exit__(self, exc_type, exc_val, exc_tb):
        """Close client resources when exiting context."""
        self.session.close()
        return False  # Don't suppress exceptions
        
    {% if async_support %}
    async def __aenter__(self):
        """Support for using client as an async context manager."""
        return self
        
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        """Close client resources when exiting async context."""
        await self.close()
        return False  # Don't suppress exceptions
    {% endif %}

    def create_dataset(
        self,
        name: str,
        description: str,
        // ... existing code ...
    ) -> Dict[str, Any]:
        """
        Create a new dataset.
        
        Args:
            name: Name of the dataset
            description: Description of the dataset
            // ... existing code ...
        
        Returns:
            Dict containing the created dataset
        """
        
        headers = {
            'Content-Type': 'application/json',
            // ... existing code ...
        }
        
        // ... existing code ...